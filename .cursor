+(code structure) Always look for existing code to iterate on instead of creating new code.
+(code structure) Do not drastically change the patterns before trying to iterate on existing patterns.
+(code structure) Avoid duplication of code whenever possible, which means checking for other areas of the codebase that might already have similar code and functionality
+(code structure) Write code that takes into account the different environments: dev, test, and prod
+(code structure) When fixing an issue or bug, do not introduce a new pattern or technology without first exhausting all options for the existing implementation. And if you finally do this, make sure to remove the old implementation afterwards so we don't have duplicate logic.
+(code structure) Never overwrite my .env file without first asking and confirming
+(code structure) Focus on the areas of code relevant to the task
+(code structure) Do not touch code that is unrelated to the task
+(code structure) Avoid making major changes to the patterns and architecture of how a feature works, after it has been shown to work well, unless explicitly instructed
+(code structure) Always think about what other methods and areas of code might be affected by code changes

+(code style) Codebase cleanliness and organization.
Maintain a clean, modular, and consistent codebase. 
    Keep file structures logical, remove unused code, and group related logic together. 
    Follow naming conventions, use consistent formatting, and document complex logic clearly. 
    Each file should serve a single clear purpose to improve readability and maintainability.
+ (code style) Enforce two-word variable naming.
All variables, fields, and properties must be named with at least two words. Disallow single-word variable names. Always extend short or generic names into a two-word compound. examplesBad:["active","type","color","mode","flag"];
examplesGood:["isActive","measurementType","textColor","displayMode", "statusFlag"];
suggestions:
    "Boolean operands should start with a prefix (is, has, can, should)."
    "For descriptive values, append a context word (measurementType, userRole, filePath)."
    "Avoid generic one-word names: replace 'color' with 'textColor' or 'bgColor'."
+(code style) Const usage limitation
Use 'const' only for immutable parameters declared at the top of the file. For changeable variables in *.ts files, use 'var' instead.
+ (code style)Import order and grouping
  description: "Group imports logically: external modules first, internal modules next, followed by style or asset imports.
+ (code style) Consistent component structure
Each component folder should contain only its logic, template, and style files. Avoid mixed-purpose folders or nested unrelated files.
+ (code style) Avoid inline styles"
Never use inline style attributes in JSX/HTML. Define styles in CSS or theme tokens for consistency and maintainability.
+ (code style)Avoid magic numbers
Never use unexplained numeric constants in code. Replace with named constants or descriptive tokens.
+ (code style) Consistent boolean naming
Boolean variables must use clear prefixes like 'is', 'has', or 'can' to indicate their nature.
+(code style) Avoid writing scripts in files if possible, especially if the script is likely only to be run once
+(code style) Mocking data is only needed for tests, never mock data for dev or prod
+(code style) Never add stubbing or fake data patterns to code that affects the dev or prod environments

+ (visual) Size units restriction
Do NOT use relative units like 'em' or '%'. Use only 'px' and predefined size tokens from the theme.
+ (visual) Opacity usage control
Do NOT use CSS opacity by default. Always warn and request approval before applying any opacity value.
+ (visual) Font size consistency.
Use only predefined font-size tokens from the theme; do not define custom font sizes in CSS.
+ (visual) Color token enforcement.
Use only predefined color tokens from the design system. Never hardcode hex, rgb, or hsl values in CSS.
+ (visual) Spacing token enforcement.
All margins, paddings, and gaps must use spacing tokens from the theme. Avoid arbitrary numeric values.
+ (visual) Z-index management.
Use named z-index tokens or centralized layers. Do not define arbitrary z-index values directly in CSS.
+ (visual) Transition consistency.
Use only predefined transition tokens (timing, duration, easing). Avoid writing custom transitions per component.
+ (visual) Border radius restriction.
Use only radius tokens from the theme. Do not define ad-hoc pixel values for rounding.

+ (architecture & logic) Separation of concerns
UI components should not contain business logic. Move logic to services, hooks, or controllers.

+ (performance) Lazy loading enforcement
Use dynamic imports or lazy loading for non-critical modules. Avoid loading all dependencies at startup.
+ (performance) Avoid unnecessary re-renders
Memoize expensive computations and component renders where applicable. Use pure components when possible.
+ (performance) Asset optimization
Do not commit uncompressed images, large media, or unnecessary assets. Always use optimized formats.